# 02.물리 모델링 저장소 설계 (⭐⭐⭐)

- 물리 데이터 모델링
    - 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정

![image](https://user-images.githubusercontent.com/64088250/191422589-eb51ee32-6fbe-4b8b-bd5c-bc0b524b6b74.png)

- 물리 모델링 변환 절차

| 순서  | 절차 |
|-----| --- |
| 1   | 개체를 테이블로 변환 |
| 2   | 속성을 컬럼으로 변환 |
| 3   | UID를 기본키로 변환 |
| 4   | 관계를 외래키로 변환 |
| 5   | 컬럼 유형과 길이 정의 |
| 6   | 반 정규화 수행 |

- 참조 무결성 제약 조건 : 릴레이션과 릴레이션 사이에 대한 참조의 일관성을 보장하기 위한 조건
    - 제한(Restricted) : 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션
    - 연쇄(Cascade) : 참조하는 테이블까지 연쇄적으로 제거하는 옵션
    - 널 값(nullity) : 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 튜플들의 외래값에 NULL 값을 넣는 옵션 (만약 NULL이 들어갈 애트리뷰트에 ‘NOT NULL’ 제약 조건이 있다면 삭제 연산을 거절)

    ```sql
    참조무결성 제약조건 SQL 문법(삭제 시)
    
    ALTER TABLE 테이블 ADD
    FOREIGN KEY (외래키)
    PEFERENCES 참조 테이블(기본키)
    ON DELETE [ RESTRICT : CASCADE : SET NULL ];
    ```

- 인덱스(Index)
    - 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조
    - 인덱스를 통해 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회 가능
- 뷰(View)
    - 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로 구성된 가상 테이블
    - 뷰 속성

| 속성 | 설명 |
| --- | --- |
| REPLACE | 뷰가 이미 존재하는 경우 재생성 |
| FORGE | 본 테이블의 존재 여부에 관계 없이 생성 |
| NOFORGE | 기본 테이블이 존재할 때 뷰 생성 |
| WITH CHECK OPTION | 서브 쿼리 내의 조건을 만족하는 행만 변경 |
| WHTH READ ONLY | 데이터 조작어 작업 불가 |
- 클러스터(Cluster)
    - 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법, 클러스터의 분포도가 넓을수록 유리
- 파티션(Partition) (래해리컴)
    - 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
    - 레인지 파티셔닝(Range Partitioning) : 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법
    - 해시 파티셔닝(Hash Partitioning) : 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
    - 리스트 파티셔닝(List Partitioning) : 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
    - 컴포지트 파티셔닝(Composite Partitioning) : 레인지, 해시, 리스트 중 2개 이상의 파티셔닝을 결합하는 파티셔닝 기법
- 파티션의 장점 (성가백합)

| 속성 | 설명 |
| --- | --- |
| 성능 향상 | 데이터 엑세스 범위를 줄여 성능 향상 |
| 가용성 향상 | 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상 |
| 백업 가능 | 분할 영역을 독립적으로 백업하고 복구가능 |
| 경합 감소 | 디스크 스트라이핑으로 입출력 성능을 향상 |

❗디스크 스트라이핑 : 성능 향상을 위해 데이터를 1개 이상의 디스크 드라이브에 저장하여 드라이브를 병렬로 사용할 수 있는 기술