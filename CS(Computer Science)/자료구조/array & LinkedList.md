# 1.자료구조

## 1-1.Array vs LinkedList

---

### 1-1-1.Array는 어떤 자료구조인가요?

Array는 연관된 data를 모아서 메모리상에 **연속적이며** **순차적으로 저장**하는 자료구조 입니다.

**고정된 저장 공간**을 가진다는 점과 **순차적으로 데이터를 저장**한다는 것이 특징입니다.

**배열은 어떻게 사용하고 어떻게 저장될까요?**

`int array[6] = {10, 20, 30, 40, 50, 60};` 라고 배열을 만들면

오른쪽 이미지와 같이 연속적으로 데이터가 저장되게 됩니다.

![img.png](배열_메모리구조.png)

**배열의 시간 복잡도**

- 조회 `O(n)`

  2번 인덱스에 어떤 값이 있는지 조회할 때 컴퓨터는 첫번째의 인덱스(배열의 이름)에 이동하는 위치 * 4바이트를 더해주면 바로 주소를 알 수 있다. (Random Access 라고 한다.)

  `0번인덱스의 주소 + (인덱스 2 * 4바이트 = 8바이트) → 2번 인덱스의 메모리 주소`

- 마지막 인덱스에 추가 `O(1)`, 마지막 인덱스에 삭제 `O(1)`
- 삽입 `O(n)`, 삭제 `O(n)`, 탐색 `O(n)`

  연속적으로 데이터가 저장되어있기 때문에, 중간에 삭제하는 경우에는 N번 땡겨줘야하고, 중간에 추가하려면 N번 늘려주어야한다.


**Array의 장점**

- 조회가 빠르다. 따라서 조회를 자주 해야되는 작업에서는 좋다.

**Array의 단점**

- fixed-size 특성때문에 크기를 미리 지정 정해야 하기 때문에, 메모리 낭비나 overhead가 발생할 수 있다.

### 1-1-1 꼬꼬무.미리 예상한 것보다 더 많은 수의 Data를 저장하느라 Array의 Size를 넘어서게 됐습니다. 이 때, 어떻게 해결할 수 있을까요?

기존의 Size보다 더 큰 Array를 선언하여 데이터를 옮겨 할당합니다. 모든 데이터를 옮겼다면 기준 Array는 메모리에서 삭제하면 됩니다.

이렇게 동적으로 배열의 크기를 조절하는 자료구조를 Dynamic Array라고 합니다.

또 다른 방법으로는, Size를 예측하기 쉽지 않다면 Array 대신 Linked List를 사용함으로써 데이터가 추가될 때마다 메모리 공간을 할당받는 방식을 사용하면 됩니다.

### 1-1-2.Dynamic Array는 어떤 자료구조 인가요?

저장공간이 가득 차게 되면 resize를 하여 유동적으로 size를 조절하여 데이터를 저장하는 자료구조 입니다.

기존에 고정된 size를 가진 Static Array의 한계점을 보안하고자 고안되었습니다. size를 미리 고민할 필요가 없다는 장점이 있습니다.

- resize: 데이터를 추가하다가 할당된 memory에 초과하게되면 size를 늘린 배열을 선언하고 그곳으로 모든 데이터를 옮김으로써 늘어난 크기의 size를 가진 배열을 만드는 것
  - resizing의 방법 중 대표적인 방법은 기존 Array size의 2배 size를 할당하는 doubling이 있습니다.


질문: Dynamic Array의 시간 복잡도는 어떻게 될까요?

답변: 데이터를 마지막 인덱스에 추가하는 작업이 대다수이고, size를 넘어설 때만 resize가 발생하기 때문에, O(1)이라고 표현할 수 있습니다. 좀 더 정확하게는 **amortized O(1)** 이라고 부릅니다.

가끔 발생하는 O(n)의 resize하는 시간을, **자주 발생하는 O(1)의 작업들이 분담해서 나눠가짐**으로써 전체적으로 O(1)이 걸린다라고 생각하면 됩니다.

### 1-1-2 꼬꼬무. Dynamic Array를 Linked List와 비교하여 장단점을 설명해 주세요.

장점

- 데이터 접근, 할당과 맨 뒤에 데이터를 추가, 삭제하는 것이 O(1)로 상대적으로 빠릅니다.

단점

- Dynamic Array의 맨 끝이 아닌 곳에 Data를 Insert, Remove할 때, O(n)으로 느린 편입니다. 메모리상에서 연속적으로 데이터들이 저장되어 있기 때문에, 데이터를 추가, 삭제할 때 뒤에 있는 Data들을 모두 한칸씩 Shift 해야되기 때문입니다.
- resize를 해야할 때 예상치 못하게 현저히 낮은 Perfomance가 발생합니다.
- resize에 시간이 많이 걸리므로 필요한 것 이상 memory공간을 할당받습니다. 따라서 사용하지 않고 있는 낭비되는 메모리 공간이 발생합니다.

### 1-1-3.Linked List에 대해서 설명해 주세요.

Linked List는 Node라는 구조체로 이루어져 있는데, Node는 데이터 값과 다음 Node의 address를 저장합니다. Linked List는 물리적인 메모리상에서는 비연속적으로 저장이 되지만 Linked List를 구성하는 각각의 Node가 다음 Node의 Address를 가리킴으로써 논리적인 연속성을 가진 자료구조 입니다.

또한, 데이터가 추가되는 시점에서 메모리를 할당하기 때문에 메모리를 좀 더 효율적으로 사용할 수 있다

**논리적 연속성**

각 Node들은 Next Address 정보를 가지고 있기 때문에 논리적으로 연속성을 유지하면서 연결되어 있습니다.

Linked List에서는 메모리의 연속성을 유지하지 않아도 되기 때문에 메모리 사용이 좀 더 자유로운 대신, Next Address를 추가적으로 저장해야 하기 때문에 데이터 하나당 차지하는 메모리가 더 커지게 됩니다.

**Linked List의 시간복잡도**

- 데이터 삽입/삭제 O(1)
- 액세스/서치 O(n)
  - Linked List는 순차적으로 데이터를 접근하기 때문에 Head부터 요소를 한개씩 탐색 하여야 한다.
  - 최악의 경우(가장 마지막에 있는 경우) N번을 탐색하기 때문에


### 1-1-4. Array vs Linked List를 비교해서 설명해주세요.

Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조 입니다. Linked List는 메모리상에서는 연속적이지 않지만, 각각의 원소가 다음 원소의 메모리 주소값을 저장해 놓음으로써 논리적 연속성을 유지합니다.

그래서 각 operation의 시간복잡도가 다릅니다. 데이터 조회는 Array의 경우 O(1), Linked List의 경우 O(n)의 시간복잡도를 갖습니다. 삽입/삭제는 Array O(n), Linked List O(1)의 시간복잡도를 갖습니다.

따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 좋습니다. 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked List를 사용하는 것이 유리합니다.

**조회 (lookup)**

Array는 메모리상에서 연속적으로 데이터를 저장하였기 때문에 저장된 데이터에 즉시 접근(random access $O(1)$)할 수 있습니다. 이와 반면 Linked List는 메모리 상에서 불연속적으로 데이터를 저장하기 때문에 순차 접근(Sequential Access)만 가능합니다. 즉, 특정 index의 데이터를 조회하기 위해 $O(n)$의 시간이 걸리게 됩니다.

**삽입/삭제 (insert/delete)**

Array의 경우 맨 마지막 원소를 추가/삭제하면 시간복잡도가 $O(1)$입니다. 하지만 맨 마지막 원소가 아닌 중간에 있는 원소를 삽입/삭제하면 해당 원소보다 큰 인덱스의 원소들을 한 칸씩 shift 해줘야 하는 비용(cost)이 발생합니다. 따라서 이 경우에는 시간복잡도가 $O(n)$이 됩니다.

Linked List는 어느 원소를 추가/삭제 하더라도 node에서 다음주소를 가르키는 부분만 다른 주소 값으로 변경하면 되기 때문에 shift할 필요 없어 시간복잡도가 $O(1)$입니다.

하지만 Linked list의 경우 추가/삭제를 하려는 index까지 도달하는데 $O(n)$의 시간이 걸리기 때문에, 실질적으로 Linked List도 추가/삭제 시에 $O(n)$의 시간이 걸린다고 볼 수 있습니다.

**memory**

Array의 주된 장점은 데이터 접근과 append가  빠르다는 것입니다. 하지만 메모리 낭비라는 단점이 있습니다. 배열은 선언시에 fixed size를 설정하여 메모리 할당을 합니다. 즉, 데이터가 저장되어 있지 않더라도 메모리를 차지하고 있기 때문에 메모리 낭비가 발생합니다.

이와 반면 Linked List는 runtime중에서도 size를 늘리고 줄일 수 있습니다. 그래서 initial size를 고민할 필요 없고, 필요한 만큼 memorry allocation을 하여 메모리 낭비가 없습니다.

### 1-1-4 꼬꼬무. Array와 Linked List의 memory allocation은 언제 일어나며, 메모리의 어느 영역을 할당 받나요?

Array는 complie 단계에서 memory allocation이 일어납니다. 이를 Static Memory Allocation이라고 합니다. 이 경우 Stack Memory영역에 할당됩니다.

Linked List의 경우 runtime 단계에서 새로운 node가 추가될 때마다 memory allocation이 일어납니다. 이를 Dynamic Memory Allocation이라고 부릅니다. 이 경우 Heap Memory영역에 할당됩니다.